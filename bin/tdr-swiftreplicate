#!/usr/bin/env perl

use strict;
use warnings;

use FindBin;
use lib "$FindBin::RealBin/../lib";
use Getopt::Long;
use CIHM::TDR::Swift;
use CIHM::TDR::SwiftReplicateWorker;

use Coro::Semaphore;
use AnyEvent::Fork;
use AnyEvent::Fork::Pool;

use Fcntl qw(:DEFAULT :flock);

my $conf = "/etc/canadiana/tdr/tdr.conf";
my $verbose;
my $lockfile = '/var/lock/tdr/tdr-swiftreplicate';
my $maxprocs = 2;
my $limit;
my $skip;
my $aip;
GetOptions ( 'conf:s' => \$conf,'verbose' => \$verbose,
	     'lockfile:s' => \$lockfile, 'maxprocs:i' => \$maxprocs,
	     'skip:i' => \$skip, 'limit:i' => \$limit,'aip:s' => \$aip);

if ($lockfile ne 'none') {
    # Only allow one instance to run at a time..
    sysopen(FH, $lockfile, O_WRONLY | O_CREAT)
	or die "can't open lockfile=$lockfile: $!\n";
    flock(FH, LOCK_EX | LOCK_NB)
	or exit 0;
}


my $swift = CIHM::TDR::Swift->new({
    configpath => $conf
				  });

if ($aip) {
    # Simple replication of a single AIP
    my %options;
    if($verbose) {
	$options{'verbose'}=1;
    }
    $swift->replicateaip($aip,\%options);
} else {
    # Using AnyEvent::Fork::Pool to replicate a few in parallel

    my %inprogress;

    my $pool = AnyEvent::Fork
        ->new
        ->require ("CIHM::TDR::SwiftReplicateWorker")
        ->AnyEvent::Fork::Pool::run
        (
         "CIHM::TDR::SwiftReplicateWorker::replicateaip",
         max        => $maxprocs,
         load       => 2,
         on_destroy => ( my $cv_finish = AE::cv ),
        );

    # Semaphore keeps us from filling the queue with too many AIPs before
    # some are processed.
    my $sem = new Coro::Semaphore ($maxprocs*2);
    my $somework;

    while (  ((! defined $limit) || $limit>0) &&
	     (my $aip = getNextAIP($swift,$maxprocs,$skip, \%inprogress))) {

	$limit-- if $limit;

        $somework=1;
        $inprogress{$aip}=1;
        $sem->down;
        $pool->($aip,$conf,$verbose,sub {
            my $aip=shift;
            $sem->up;
            delete $inprogress{$aip};
                });
    }
    undef $pool;
    if ($somework) {
        $swift->log->info("Waiting for child processes to finish");
    }
    $cv_finish->recv;
    if ($somework) {
        $swift->log->info("Finished.");
    }
}

sub getNextAIP {
    my ($swift,$maxprocs,$skip,$inprogress) = @_;

    # Ensure there is enough to skip all those in progress
    my $opts = { limit => ($maxprocs*2+2)};
    if ($skip) {
	$opts->{skip}=$skip;
    }

    my @replicateaips=$swift->tdrepo->get_replicate($opts);
    foreach my $aip (@replicateaips) {
	if (! exists $inprogress->{$aip}) {
	    return $aip;
	}
    }
    return;
}



1;
